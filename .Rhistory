library(roxygen2)
renv::deactivate()
renv::deactivate()
library(roxygen2)
library(roxygen2)
usethis::use_gpl3_license()
getwd()
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/Data files")
readxl("temp0.xlsx")
library(readxl)
temp0 = readxl("temp0.xlsx")
temp0 = read_excel("temp0.xlsx")
temp0
dim(temp0)
residuals = read_excel("residuals.xlsx")
dim(residuals)
sresids = read_excel("sresids.xlsx")
dim(sresids)
tempstations = read_excel("tempstations.xlsx")
tempstations
dim(tempstations)
seasonal_coefs = read_excel("seasonal_coefs.xlsx")
dim(seasonal_coefs)
getwd()
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
library(usethis)
usethis::use_data(temp0, compress = "xz")
load("~/Desktop/PhD/STAT600/Project/priceT/data/temp0.rda")
head(temp0)
data.frame(temp0)
array(temp0)
temp0 = array(temp0)
head(temp0)
getwd()
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/Data files")
temp0 = read_excel("temp0.xlsx")
temp0 = as.matrix(temp0)
temp0
temp0[52,53]
as.numeric(temp0[52,53])
as.numeric(temp0)
as.matrix(temp0[,3:227])
as.numeric(as.matrix(temp0[,3:227]))
length(as.numeric(as.matrix(temp0[,3:227])))
dim(as.numeric(as.matrix(temp0[,3:227])))
temp0 = read_excel("temp0.xlsx")
temp0 = as.matrix(temp0)
temp0
dim(temp0)
tempstations = as.matrix(tempstations)
tempstations
residuals = as.matrix(residuals)
dim(residuals)
seasonal_coefs = as.matrix(seasonal_coefs)
seasonal_coefs
temp0 = read_excel("temp0.xlsx")
temp0
temp0 = as.matrix(temp0)
temp0
dim(temp0)
dim(residuals)
dim(tempstations)
dim(seasonal_coefs)
residuals
sresids = as.matrix(sresids)
sresids
dim(sresids)
getwd()
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
usethis::use_data(temp0, compress = "xz")
usethis::use_data(residuals, compress = "xz")
usethis::use_data(sresids, compress = "xz")
usethis::use_data(tempstations, compress = "xz")
usethis::use_data(seasonal_coefs, compress = "xz")
usethis::use_data(residuals, compress = "xz")
getwd()
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/Data files")
temp0 = read_excel("temp0.xlsx")
temp0 = as.matrix(temp0)
temp0
dim(temp0)
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
usethis::use_data(temp0, compress = "xz")
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/Data files")
temp0 = read_excel("temp0.xlsx")
temp0 = as.matrix(temp0)
dim(temp0)
temp0
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
usethis::use_data(temp0, compress = "xz")
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/Data files")
temp0 = read_excel("temp0.xlsx")
temp0 = as.matrix(temp0)
dim(temp0)
temp0
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
usethis::use_data(temp0, compress = "xz")
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/Data files")
residuals = read_excel("residuals.xlsx")
residuals = as.matrix(residuals)
residuals
dim(residuals)
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
usethis::use_data(residuals, compress = "xz")
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/Data files")
residuals = read_excel("residuals.xlsx")
residuals = as.matrix(residuals)
residuals
dim(residuals)
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
usethis::use_data(residuals, compress = "xz")
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/Data files")
residuals = read_excel("residuals.xlsx")
residuals = as.matrix(residuals)
residuals
dim(residuals)
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
usethis::use_data(residuals, compress = "xz")
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/Data files")
residuals = read_excel("residuals.xlsx")
residuals = as.matrix(residuals)
residuals
dim(residuals)
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
usethis::use_data(residuals, compress = "xz")
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/Data files")
sresids = read_excel("sresids.xlsx")
sresids = as.matrix(sresids)
sresids
dim(resids)
dim(sresids)
setwd("/Users/wangzexianleo/Desktop/PhD/STAT600/Project/priceT/data")
usethis::use_data(sresids, compress = "xz")
load("~/Desktop/PhD/STAT600/Project/priceT/data/temp0.rda")
temp0
dim(temp0)
load("~/Desktop/PhD/STAT600/Project/priceT/data/seasonal_coefs.rda")
seasonal_coefs
dim(seasonal_coefs)
load("~/Desktop/PhD/STAT600/Project/priceT/data/tempstations.rda")
tempstations
dim(tempstations)
load("~/Desktop/PhD/STAT600/Project/priceT/data/residuals.rda")
residuals
dim(residuals)
load("~/Desktop/PhD/STAT600/Project/priceT/data/sresids.rda")
sresids
dim(sresids)
is.vector(c(1,2,3))
params = c(1,2,3,4)
t = c(1,2,3,4,5)
loc1temperatures=c(20,30,40,50,60)
S = (params[1] + params[2]*t + params[3]*cos(2*pi*(t - params[4])/365) - loc1temperatures)^2
S
S = params[1] + params[2] * t + params[3] * cos(2 * pi * (t - params[4]) / 365)
S2 = S^2 - 2 * S * loc1temperatures + loc1temperatures^2
S2
load("~/Desktop/PhD/STAT600/Project/priceT/data/temp0.rda")
temp = temp0[,3]
temp
temp = as.numeric(temp)
temp
# Function that returns the estimated coefficients of the seasonality function
# temp = n by 1 vector containing the past temperatures data at one station over (n / 365) years
seasonal = function(temp) {
# compatibility check
if (is.vector(temp) == FALSE) {
stop("temp should be a vector.") # returns error message if the input temp is not a vector
}
n = length(temp)
t = 1:n # times indices
initial = c(50, 0, 35, 0) # initialise parameter values for optimisation
# perform minimisation
loc1optim = optim(par = initial, fn = loc1temp, t = t, loc1temperatures = temp, method = "L-BFGS-B")
# estimated parameters from minimisation
loc1a = loc1optim$par[1]
loc1b = loc1optim$par[2]
loc1c = loc1optim$par[3]
loc1d = loc1optim$par[4]
# computes the fitted seasonality function
loc1fitted = loc1a + loc1b * t + loc1c * cos(2 * pi * (t - loc1d) / 365)
# plotting the temperatures and seasonal function
plot(t, temp, type = "l", col = "blue", xlab = "Time", ylab = "Temperature", lwd = 2)
lines(t, loc1fitted, col = "gold", lwd = 2.5)
saved_plot = recordPlot() # saving the plot
# returns the estimated coefficients of the seasonality function,
# the fitted seasonality function and the graph plotted
return(c(a = loc1a, b = loc1b, c = loc1c, d = loc1d, seasonality = loc1fitted, plt = saved_plot))
}
# Function that computes and returns the objective function for fitting the seasonality function
loc1temp = function(params, t, loc1temperatures) {
# computes the seasonality function
S = params[1] + params[2] * t + params[3] * cos(2 * pi * (t - params[4]) / 365)
# computes the squared difference between the seasonality and the observed values of the temperature
S2 = S^2 - 2 * S * loc1temperatures + loc1temperatures^2
return(S2) # returns the objective function
}
seasonal(temp)
# Function that returns the estimated coefficients of the seasonality function
# temp = n by 1 vector containing the past temperatures data at one station over (n / 365) years
seasonal = function(temp) {
# compatibility check
if (is.vector(temp) == FALSE) {
stop("temp should be a vector.") # returns error message if the input temp is not a vector
}
n = length(temp)
t = 1:n # times indices
initial = c(50, 0, 35, 0) # initialise parameter values for optimisation
# perform minimisation
loc1optim = optim(par = initial, fn = loc1temp, t = t, loc1temperatures = temp, method = "L-BFGS-B")
# estimated parameters from minimisation
loc1a = loc1optim$par[1]
loc1b = loc1optim$par[2]
loc1c = loc1optim$par[3]
loc1d = loc1optim$par[4]
# computes the fitted seasonality function
loc1fitted = loc1a + loc1b * t + loc1c * cos(2 * pi * (t - loc1d) / 365)
# plotting the temperatures and seasonal function
plot(t, temp, type = "l", col = "blue", xlab = "Time", ylab = "Temperature", lwd = 2)
lines(t, loc1fitted, col = "gold", lwd = 2.5)
saved_plot = recordPlot() # saving the plot
# returns the estimated coefficients of the seasonality function,
# the fitted seasonality function and the graph plotted
return(c(a = loc1a, b = loc1b, c = loc1c, d = loc1d, seasonality = loc1fitted, plt = saved_plot))
}
# Function that computes and returns the objective function for fitting the seasonality function
loc1temp = function(params, t, loc1temperatures) {
# computes the seasonality function
S = params[1] + params[2] * t + params[3] * cos(2 * pi * (t - params[4]) / 365)
# computes the squared difference between the seasonality and the observed values of the temperature
S2 = sum(S^2 - 2 * S * loc1temperatures + loc1temperatures^2)
return(S2) # returns the objective function
}
seasonal(temp)
seasonal = seasonal(temp)
seasonal$a
seasonal$b
seasonal$c
seasonal$d
seasonal$seasonality1
seasonal$seasonality
c(1:3)
# Function that returns the estimated coefficients of the seasonality function
# temp = n by 1 vector containing the past temperatures data at one station over (n / 365) years
seasonal = function(temp) {
# compatibility check
if (is.vector(temp) == FALSE) {
stop("temp should be a vector.") # returns error message if the input temp is not a vector
}
n = length(temp)
t = c(1:n) # times indices
initial = c(50, 0, 35, 0) # initialise parameter values for optimisation
# perform minimisation
loc1optim = optim(par = initial, fn = loc1temp, t = t, loc1temperatures = temp, method = "L-BFGS-B")
# estimated parameters from minimisation
loc1a = loc1optim$par[1]
loc1b = loc1optim$par[2]
loc1c = loc1optim$par[3]
loc1d = loc1optim$par[4]
# computes the fitted seasonality function
loc1fitted = loc1a + loc1b * t + loc1c * cos(2 * pi * (t - loc1d) / 365)
# plotting the temperatures and seasonal function
plot(t, temp, type = "l", col = "blue", xlab = "Time", ylab = "Temperature", lwd = 2)
lines(t, loc1fitted, col = "gold", lwd = 2.5)
saved_plot = recordPlot() # saving the plot
# returns the estimated coefficients of the seasonality function,
# the fitted seasonality function and the graph plotted
return(c(a = loc1a, b = loc1b, c = loc1c, d = loc1d, seasonality = loc1fitted, plt = saved_plot))
}
# Function that computes and returns the objective function for fitting the seasonality function
loc1temp = function(params, t, loc1temperatures) {
# computes the seasonality function
S = params[1] + params[2] * t + params[3] * cos(2 * pi * (t - params[4]) / 365)
# computes the squared difference between the seasonality and the observed values of the temperature
S2 = sum(S^2 - 2 * S * loc1temperatures + loc1temperatures^2)
return(S2) # returns the objective function
}
seasonal = seasonal(temp)
seasonal$seasonality
n = length(temp)
t = c(1:n) # times indices
initial = c(50, 0, 35, 0) # initialise parameter values for optimisation
# perform minimisation
loc1optim = optim(par = initial, fn = loc1temp, t = t, loc1temperatures = temp, method = "L-BFGS-B")
# estimated parameters from minimisation
loc1a = loc1optim$par[1]
loc1b = loc1optim$par[2]
loc1c = loc1optim$par[3]
loc1d = loc1optim$par[4]
loc1fitted = loc1a + loc1b * t + loc1c * cos(2 * pi * (t - loc1d) / 365)
loc1fitted
# Function that returns the estimated coefficients of the seasonality function
# temp = n by 1 vector containing the past temperatures data at one station over (n / 365) years
seasonal = function(temp) {
# compatibility check
if (is.vector(temp) == FALSE) {
stop("temp should be a vector.") # returns error message if the input temp is not a vector
}
n = length(temp)
t = c(1:n) # times indices
initial = c(50, 0, 35, 0) # initialise parameter values for optimisation
# perform minimisation
loc1optim = optim(par = initial, fn = loc1temp, t = t, loc1temperatures = temp, method = "L-BFGS-B")
# estimated parameters from minimisation
loc1a = loc1optim$par[1]
loc1b = loc1optim$par[2]
loc1c = loc1optim$par[3]
loc1d = loc1optim$par[4]
# computes the fitted seasonality function
seasonality = loc1a + loc1b * t + loc1c * cos(2 * pi * (t - loc1d) / 365)
# plotting the temperatures and seasonal function
plot(t, temp, type = "l", col = "blue", xlab = "Time", ylab = "Temperature", lwd = 2)
lines(t, seasonality, col = "gold", lwd = 2.5)
saved_plot = recordPlot() # saving the plot
# returns the estimated coefficients of the seasonality function,
# the fitted seasonality function and the graph plotted
return(c(a = loc1a, b = loc1b, c = loc1c, d = loc1d, seasonality, plt = saved_plot))
}
# Function that computes and returns the objective function for fitting the seasonality function
loc1temp = function(params, t, loc1temperatures) {
# computes the seasonality function
S = params[1] + params[2] * t + params[3] * cos(2 * pi * (t - params[4]) / 365)
# computes the squared difference between the seasonality and the observed values of the temperature
S2 = sum(S^2 - 2 * S * loc1temperatures + loc1temperatures^2)
return(S2) # returns the objective function
}
seasonal(temp)
seasonal = function(temp) {
# compatibility check
if (is.vector(temp) == FALSE) {
stop("temp should be a vector.") # returns error message if the input temp is not a vector
}
n = length(temp)
t = c(1:n) # times indices
initial = c(50, 0, 35, 0) # initialise parameter values for optimisation
# perform minimisation
loc1optim = optim(par = initial, fn = loc1temp, t = t, loc1temperatures = temp, method = "L-BFGS-B")
# estimated parameters from minimisation
loc1a = loc1optim$par[1]
loc1b = loc1optim$par[2]
loc1c = loc1optim$par[3]
loc1d = loc1optim$par[4]
# computes the fitted seasonality function
seasonality = loc1a + loc1b * t + loc1c * cos(2 * pi * (t - loc1d) / 365)
# plotting the temperatures and seasonal function
plot(t, temp, type = "l", col = "blue", xlab = "Time", ylab = "Temperature", lwd = 2)
lines(t, seasonality, col = "gold", lwd = 2.5)
saved_plot = recordPlot() # saving the plot
# returns the estimated coefficients of the seasonality function,
# the fitted seasonality function and the graph plotted
return(c(a = loc1a, b = loc1b, c = loc1c, d = loc1d, plt = saved_plot))
}
# Function that computes and returns the objective function for fitting the seasonality function
loc1temp = function(params, t, loc1temperatures) {
# computes the seasonality function
S = params[1] + params[2] * t + params[3] * cos(2 * pi * (t - params[4]) / 365)
# computes the squared difference between the seasonality and the observed values of the temperature
S2 = sum(S^2 - 2 * S * loc1temperatures + loc1temperatures^2)
return(S2) # returns the objective function
}
seaosnal(temp)
seasonal(temp)
# Function that returns the estimated coefficients of the seasonality function
# temp = n by 1 vector containing the past temperatures data at one station over (n / 365) years
seasonal = function(temp) {
# compatibility check
if (is.vector(temp) == FALSE) {
stop("temp should be a vector.") # returns error message if the input temp is not a vector
}
n = length(temp)
t = c(1:n) # times indices
initial = c(50, 0, 35, 0) # initialise parameter values for optimisation
# perform minimisation
loc1optim = optim(par = initial, fn = loc1temp, t = t, loc1temperatures = temp, method = "L-BFGS-B")
# estimated parameters from minimisation
loc1a = loc1optim$par[1]
loc1b = loc1optim$par[2]
loc1c = loc1optim$par[3]
loc1d = loc1optim$par[4]
# computes the fitted seasonality function
loc1fitted = loc1a + loc1b * t + loc1c * cos(2 * pi * (t - loc1d) / 365)
# plotting the temperatures and seasonal function
plot(t, temp, type = "l", col = "blue", xlab = "Time", ylab = "Temperature", lwd = 2)
lines(t, loc1fitted, col = "gold", lwd = 2.5)
# returns the estimated coefficients of the seasonality function,
# the fitted seasonality function and the graph plotted
return(c(a = loc1a, b = loc1b, c = loc1c, d = loc1d, seasonality = loc1fitted))
}
# Function that computes and returns the objective function for fitting the seasonality function
loc1temp = function(params, t, loc1temperatures) {
# computes the seasonality function
S = params[1] + params[2] * t + params[3] * cos(2 * pi * (t - params[4]) / 365)
# computes the squared difference between the seasonality and the observed values of the temperature
S2 = sum(S^2 - 2 * S * loc1temperatures + loc1temperatures^2)
return(S2) # returns the objective function
}
seasonal(temp)
# Function that returns the estimated coefficients of the seasonality function
# temp = n by 1 vector containing the past temperatures data at one station over (n / 365) years
seasonal = function(temp) {
# compatibility check
if (is.vector(temp) == FALSE) {
stop("temp should be a vector.") # returns error message if the input temp is not a vector
}
n = length(temp)
t = c(1:n) # times indices
initial = c(50, 0, 35, 0) # initialise parameter values for optimisation
# perform minimisation
loc1optim = optim(par = initial, fn = loc1temp, t = t, loc1temperatures = temp, method = "L-BFGS-B")
# estimated parameters from minimisation
loc1a = loc1optim$par[1]
loc1b = loc1optim$par[2]
loc1c = loc1optim$par[3]
loc1d = loc1optim$par[4]
# computes the fitted seasonality function
loc1fitted = loc1a + loc1b * t + loc1c * cos(2 * pi * (t - loc1d) / 365)
# plotting the temperatures and seasonal function
plot(t, temp, type = "l", col = "blue", xlab = "Time", ylab = "Temperature", lwd = 2)
lines(t, loc1fitted, col = "gold", lwd = 2.5)
# returns the estimated coefficients of the seasonality function,
# the fitted seasonality function and the graph plotted
return(a = loc1a, b = loc1b, c = loc1c, d = loc1d, seasonality = loc1fitted)
}
# Function that computes and returns the objective function for fitting the seasonality function
loc1temp = function(params, t, loc1temperatures) {
# computes the seasonality function
S = params[1] + params[2] * t + params[3] * cos(2 * pi * (t - params[4]) / 365)
# computes the squared difference between the seasonality and the observed values of the temperature
S2 = sum(S^2 - 2 * S * loc1temperatures + loc1temperatures^2)
return(S2) # returns the objective function
}
seasonal(temp)
# Function that returns the estimated coefficients of the seasonality function
# temp = n by 1 vector containing the past temperatures data at one station over (n / 365) years
seasonal = function(temp) {
# compatibility check
if (is.vector(temp) == FALSE) {
stop("temp should be a vector.") # returns error message if the input temp is not a vector
}
n = length(temp)
t = c(1:n) # times indices
initial = c(50, 0, 35, 0) # initialise parameter values for optimisation
# perform minimisation
loc1optim = optim(par = initial, fn = loc1temp, t = t, loc1temperatures = temp, method = "L-BFGS-B")
# estimated parameters from minimisation
loc1a = loc1optim$par[1]
loc1b = loc1optim$par[2]
loc1c = loc1optim$par[3]
loc1d = loc1optim$par[4]
# computes the fitted seasonality function
loc1fitted = loc1a + loc1b * t + loc1c * cos(2 * pi * (t - loc1d) / 365)
# plotting the temperatures and seasonal function
plot(t, temp, type = "l", col = "blue", xlab = "Time", ylab = "Temperature", lwd = 2)
lines(t, loc1fitted, col = "gold", lwd = 2.5)
saved_plot = recordPlot() # save the plot
# returns the estimated coefficients of the seasonality function,
# the fitted seasonality function and the graph plotted
return(list(a = loc1a, b = loc1b, c = loc1c, d = loc1d, seasonality = loc1fitted, plt = saved_plot))
}
# Function that computes and returns the objective function for fitting the seasonality function
loc1temp = function(params, t, loc1temperatures) {
# computes the seasonality function
S = params[1] + params[2] * t + params[3] * cos(2 * pi * (t - params[4]) / 365)
# computes the squared difference between the seasonality and the observed values of the temperature
S2 = sum(S^2 - 2 * S * loc1temperatures + loc1temperatures^2)
return(S2) # returns the objective function
}
seasonal(temp)
seasonal = seasonal(temp)
seasonal$plt
load("~/Desktop/PhD/STAT600/Project/priceT/data/temp0.rda")
temp = as.numeric(temp0[,3])
seasonal = seasonal(temp)
# Function that returns the estimated coefficients of the seasonality function
# temp = n by 1 vector containing the past temperatures data at one station over (n / 365) years
seasonal = function(temp) {
# compatibility check
if (is.vector(temp) == FALSE) {
stop("temp should be a vector.") # returns error message if the input temp is not a vector
}
n = length(temp)
t = c(1:n) # times indices
initial = c(50, 0, 35, 0) # initialise parameter values for optimisation
# perform minimisation
loc1optim = optim(par = initial, fn = loc1temp, t = t, loc1temperatures = temp, method = "L-BFGS-B")
# estimated parameters from minimisation
loc1a = loc1optim$par[1]
loc1b = loc1optim$par[2]
loc1c = loc1optim$par[3]
loc1d = loc1optim$par[4]
# computes the fitted seasonality function
loc1fitted = loc1a + loc1b * t + loc1c * cos(2 * pi * (t - loc1d) / 365)
# plotting the temperatures and seasonal function
plot(t, temp, type = "l", col = "blue", xlab = "Time", ylab = "Temperature", lwd = 2)
lines(t, loc1fitted, col = "gold", lwd = 2.5)
saved_plot = recordPlot() # save the plot
# returns the estimated coefficients of the seasonality function,
# the fitted seasonality function and the graph plotted
return(list(a = loc1a, b = loc1b, c = loc1c, d = loc1d, seasonality = loc1fitted, plt = saved_plot))
}
# Function that computes and returns the objective function for fitting the seasonality function
loc1temp = function(params, t, loc1temperatures) {
# computes the seasonality function
S = params[1] + params[2] * t + params[3] * cos(2 * pi * (t - params[4]) / 365)
# computes the squared difference between the seasonality and the observed values of the temperature
S2 = sum(S^2 - 2 * S * loc1temperatures + loc1temperatures^2)
return(S2) # returns the objective function
}
seasonal = seasonal(temp)
seasonal$plt
